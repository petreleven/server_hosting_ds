<div class="max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold text-emerald-700 pb-4 mb-6 border-b-2 border-emerald-500">
            <span id="config-title">Game Server Configuration</span>
        </h1>

        <form id="game-config-form" hx-post="/save-config" hx-target="#form-response"
              class="glass-card shadow-md rounded-lg p-6">

            <!-- Dynamic form will be generated here -->
            <div id="form-container"></div>

            <div class="mt-8">
                <button type="submit"
                        class="bg-emerald-600 hover:bg-emerald-700 text-white font-medium py-2 px-6 rounded-md focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2 transition-colors">
                    Save Configuration
                </button>
            </div>

            <div id="form-response" class="mt-4"></div>
        </form>
    </div>

    <script>
        /**
         * Generate HTML form elements from a JSON schema
         */
        class SchemaFormGenerator {
            constructor(config, formContainer) { // Modified constructor
                this.config = config; // Store the whole config object
                this.formContainer = formContainer;
                this.advancedFields = [];
                this.basicFields = ['name', 'port', 'world', 'password']; // Common fields across game servers
            }

            init() {
                // Set page title
                if (this.config.title) {
                    document.getElementById('config-title').textContent = this.config.title;
                }

                // Generate form fields for properties
                if (this.config.properties) {
                    this.generateBasicFields();
                    this.generateAdvancedFields();
                }
            }

            generateBasicFields() {
                const basicFieldsContainer = document.createElement('div');
                basicFieldsContainer.className = 'mb-6';

                // Process properties
                for (const [key, prop] of Object.entries(this.config.properties)) { // Iterate over this.config.properties
                    if (this.basicFields.includes(key)) {
                        basicFieldsContainer.appendChild(this.createField(key, prop));
                    }
                }

                this.formContainer.appendChild(basicFieldsContainer);
            }

            generateAdvancedFields() {
                const advancedContainer = document.createElement('div');
                advancedContainer.className = 'mb-6';

                const details = document.createElement('details');
                details.className = 'border border-gray-200 rounded-md';

                const summary = document.createElement('summary');
                summary.className = 'bg-gray-100 px-4 py-3 font-medium text-emerald-700 cursor-pointer hover:bg-gray-200';
                summary.textContent = 'Advanced Settings';

                const content = document.createElement('div');
                content.className = 'p-4 bg-gray-50';

                // Process properties
                for (const [key, prop] of Object.entries(this.config.properties)) { // Iterate over this.config.properties
                    if (!this.basicFields.includes(key)) {
                        // Handle nested objects separately
                        if (prop.type === 'object') {
                            content.appendChild(this.createObjectField(key, prop));
                        } else {
                            content.appendChild(this.createField(key, prop));
                        }
                    }
                }

                details.appendChild(summary);
                details.appendChild(content);
                advancedContainer.appendChild(details);
                this.formContainer.appendChild(advancedContainer);
            }

            createField(name, prop) { // Changed schema to prop
                const fieldContainer = document.createElement('div');
                fieldContainer.className = 'mb-6';

                // Special handling for boolean types (checkboxes)
                if (prop.type === 'boolean') {
                    return this.createCheckboxField(name, prop);
                }

                // Create label
                const label = document.createElement('label');
                label.setAttribute('for', name);
                label.className = 'block font-medium mb-1';
                label.textContent = this.formatLabel(name) + ':';
                fieldContainer.appendChild(label);

                // Create description if available
                if (prop.description) {
                    const description = document.createElement('p');
                    description.className = 'text-sm text-gray-500 mb-2';
                    description.textContent = prop.description;
                    fieldContainer.appendChild(description);
                }

                // Create input based on type
                let input;
                const inputClasses = 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-emerald-500 bg-gray-800 text-white';

                if (prop.type === 'integer' || prop.type === 'number') {
                    input = document.createElement('input');
                    input.type = 'number';
                    input.id = name;
                    input.name = name;

                    if (prop.minimum !== undefined) input.min = prop.minimum;
                    if (prop.maximum !== undefined) input.max = prop.maximum;
                    // Use prop.value if available, otherwise prop.default
                    input.value = prop.value !== undefined ? prop.value : (prop.default !== undefined ? prop.default : '');


                } else if (prop.type === 'string' && prop.enum) {
                    input = document.createElement('select');
                    input.id = name;
                    input.name = name;

                    prop.enum.forEach(enumValue => { // Changed value to enumValue to avoid conflict
                        const option = document.createElement('option');
                        option.value = enumValue;
                        option.textContent = enumValue;
                        // Use prop.value if available for selection, otherwise prop.default
                        if (prop.value !== undefined && prop.value === enumValue) {
                            option.selected = true;
                        } else if (prop.value === undefined && prop.default === enumValue) {
                            option.selected = true;
                        }
                        input.appendChild(option);
                    });

                } else {
                    // Default to text input
                    input = document.createElement('input');
                    input.type = name.toLowerCase().includes('password') ? 'password' : 'text';
                    input.id = name;
                    input.name = name;

                    if (prop.minLength !== undefined) input.minLength = prop.minLength;
                    // Use prop.value if available, otherwise prop.default
                    input.value = prop.value !== undefined ? prop.value : (prop.default !== undefined ? prop.default : '');
                }

                // Add common attributes
                input.className = inputClasses;
                if (this.config.required && this.config.required.includes(name)) { // Check this.config.required
                    input.required = true;
                }

                fieldContainer.appendChild(input);
                return fieldContainer;
            }

            createCheckboxField(name, prop) { // Changed schema to prop
                const fieldContainer = document.createElement('div');
                fieldContainer.className = 'mb-2';

                const label = document.createElement('label');
                label.className = 'flex items-center';

                const input = document.createElement('input');
                input.type = 'checkbox';
                input.id = name;
                input.name = name;
                input.className = 'h-5 w-5 text-emerald-600 rounded focus:ring-emerald-500';

                // Use prop.value if available, otherwise prop.default
                input.checked = prop.value !== undefined ? prop.value : (prop.default === true);


                const span = document.createElement('span');
                span.className = 'ml-2';
                span.textContent = prop.description || this.formatLabel(name);

                label.appendChild(input);
                label.appendChild(span);
                fieldContainer.appendChild(label);

                return fieldContainer;
            }

            createObjectField(name, prop) { // Changed schema to prop
                const sectionContainer = document.createElement('div');
                sectionContainer.className = 'border border-gray-200 rounded-md p-4 mb-6';

                const heading = document.createElement('h3');
                heading.className = 'font-medium mb-3';
                heading.textContent = this.formatLabel(name);
                sectionContainer.appendChild(heading);

                // Process nested properties
                if (prop.properties) { // Check prop.properties
                    for (const [key, nestedProp] of Object.entries(prop.properties)) { // Changed prop to nestedProp
                        const fieldName = `${name}[${key}]`; // This might need adjustment based on how form data is submitted for nested objects

                        if (nestedProp.type === 'boolean') {
                            // Pass the specific value for the nested property if available
                            const valueProp = { ...nestedProp, value: (prop.value && prop.value[key] !== undefined) ? prop.value[key] : nestedProp.default };
                            sectionContainer.appendChild(this.createCheckboxField(fieldName, valueProp));
                        } else if (nestedProp.type === 'string' && nestedProp.enum) {
                            const fieldContainer = document.createElement('div');
                            fieldContainer.className = 'mb-4';

                            const label = document.createElement('label');
                            label.setAttribute('for', fieldName);
                            label.className = 'block font-medium mb-1';
                            label.textContent = this.formatLabel(key) + ':';
                            fieldContainer.appendChild(label);

                            const select = document.createElement('select');
                            select.id = fieldName;
                            select.name = fieldName;
                            select.className = 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-emerald-500';
                            
                            // Pass the specific value for the nested property if available
                            const currentVal = (prop.value && prop.value[key] !== undefined) ? prop.value[key] : nestedProp.default;

                            nestedProp.enum.forEach(enumValue => {
                                const option = document.createElement('option');
                                option.value = enumValue;
                                option.textContent = this.formatOptionLabel(enumValue);
                                if (currentVal === enumValue) option.selected = true;
                                select.appendChild(option);
                            });

                            fieldContainer.appendChild(select);
                            sectionContainer.appendChild(fieldContainer);
                        } else {
                            // Pass the specific value for the nested property if available
                             const valueProp = { ...nestedProp, value: (prop.value && prop.value[key] !== undefined) ? prop.value[key] : nestedProp.default };
                            sectionContainer.appendChild(this.createField(fieldName, valueProp));
                        }
                    }
                }

                return sectionContainer;
            }

            formatLabel(text) {
                // Convert camelCase or snake_case to Title Case
                return text
                    .replace(/([A-Z])/g, ' $1') // Insert space before capital letters
                    .replace(/_/g, ' ') // Replace underscores with spaces
                    .replace(/^\w/, c => c.toUpperCase()) // Capitalize first letter
                    .trim();
            }

            formatOptionLabel(text) {
                // Convert enum values to more readable format
                return text
                    .replace(/([A-Z])/g, ' $1') // Insert space before capital letters
                    .replace(/_/g, ' ') // Replace underscores with spaces
                    .replace(/^\w/, c => c.toUpperCase()) // Capitalize first letter
                    .replace(/muchless/i, 'Much Less')
                    .replace(/muchmore/i, 'Much More')
                    .replace(/veryeasy/i, 'Very Easy')
                    .replace(/veryhard/i, 'Very Hard')
                    .trim();
            }
        }
        create();
        // Example usage
        function create() {
            // Get the config data passed from the server
            // The '{{ config | tojson | safe }}' part will be rendered by the template engine
            // Ensure that 'config' is properly passed to this template from your server-side route
            const serverConfig = JSON.parse('{{ config | tojson | safe }}');

            // Initialize form generator with the server-provided config
            const formGenerator = new SchemaFormGenerator(serverConfig, document.getElementById('form-container'));
            formGenerator.init();

            // Fetch games list for dropdown (in production) - This part can be kept if needed for other functionalities
            // Example function to switch between game schemas - This part can be kept if needed for other functionalities
            // However, if this page is solely for the current 'config', this function might not be directly used here.
            function loadGameSchema(gameId) {
                fetch(`/api/game-schema/${gameId}`) // This would fetch a schema, not a config with values
                    .then(response => response.json())
                    .then(schema => {
                        // Clear existing form
                        const container = document.getElementById('form-container');
                        container.innerHTML = '';

                        // Generate new form. If this function is to be used,
                        // it should ideally fetch a full config object (schema + values)
                        // or you'd need a separate mechanism to get current values for the new schema.
                        // For now, assuming it re-initializes with a schema which might only have defaults.
                        const formGenerator = new SchemaFormGenerator(schema, container); // This would use schema, not serverConfig with values
                        formGenerator.init();
                    });
            }
        };
    </script>
</div>
